#include <Adafruit_MotorShield.h>
#include <hp_BH1750.h>  //light sensor

#define IR_PIN_1 A0
#define IR_PIN_2 A1
#define LEFT_MOTOR_PIN_1 1
#define LEFT_MOTOR_PIN_2 2
#define RIGHT_MOTOR_PIN_3 3
#define RIGHT_MOTOR_PIN_4 4

Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_DCMotor *LEFT_MOTOR_1 = AFMS.getMotor(LEFT_MOTOR_PIN_1);
Adafruit_DCMotor *LEFT_MOTOR_2 = AFMS.getMotor(LEFT_MOTOR_PIN_2);
Adafruit_DCMotor *RIGHT_MOTOR_3 = AFMS.getMotor(RIGHT_MOTOR_PIN_3);
Adafruit_DCMotor *RIGHT_MOTOR_4 = AFMS.getMotor(RIGHT_MOTOR_PIN_4);

int sensorValue1;
int sensorValue2;
int sensorValue3;
int sensorValue4;
int MAX_SPEED = 255;

hp_BH1750 lightSensor;

int lightTurnedOn = 0;  //kinda like a boolean
int LUX_THRESHOLD = 3000;

void setup() {
  //IR pins
  pinMode(IR_PIN_1, INPUT);
  pinMode(IR_PIN_2, INPUT);
  pinMode(IR_PIN_3, INPUT);
  pinMode(IR_PIN_4, INPUT);

  //driver
  AFMS.begin();

  //motors
  LEFT_MOTOR_1->setSpeed(0);
  LEFT_MOTOR_2->setSpeed(0);
  RIGHT_MOTOR_3->setSpeed(0);
  RIGHT_MOTOR_4->setSpeed(0);
  LEFT_MOTOR_1->run(RELEASE);
  LEFT_MOTOR_2->run(RELEASE);
  RIGHT_MOTOR_3->run(RELEASE);
  RIGHT_MOTOR_4->run(RELEASE);

  //light sensor
  lightSensor.begin(BH1750_TO_GROUND);
}

void loop() {

  //light sensor (robot initialization step)

  lightSensor.start();
  int lux = lightSensor.getLux();

  if (lux > 3000) {
    if (lightTurnedOn == 0)
      lightTurnedOn = 1;
    else
      lightTurnedOn = 0;
  }

  if (lightTurnedOn == 1) {

    //black returns 0, white returns 1
    sensorValue1 = digitalRead(IR_PIN_1);  //left outer
    sensorValue2 = digitalRead(IR_PIN_2);  //right outer
    sensorValue1 = digitalRead(IR_PIN_3);  //left inner
    sensorValue1 = digitalRead(IR_PIN_4);  //right inner

    // Directions:

    if (sensorValue1 == 0 && sensorValue2 == 0 && sensorValue3 == 1 && sensorValue4 == 1) {  // straight
      straight();
    } else if (sensorValue1 == 0 && sensorValue2 == 0 && sensorValue3 == 1 && sensorValue4 == 0) {  // curve
      left();
    } else if (sensorValue1 == 0 && sensorValue2 == 0 && sensorValue3 == 0 && sensorValue4 == 1) {  // curve
      right();
    } else if (sensorValue1 == 0 && sensorValue2 == 1 && sensorValue3 == 0 && sensorValue4 == 0) {  // 90 degree
      leftSharp();
      delay(2000);
    } else if (sensorValue1 == 1 && sensorValue2 == 0 && sensorValue3 == 0 && sensorValue4 == 0) {  // 90 degree
      rightSharp();
      delay(2000);
    } else if (sensorValue1 == 0 && sensorValue2 == 0 && sensorValue3 == 0 && sensorValue4 == 0) {  // Intersection & dashed line
      intersection();
    }
  } else
    stop();
}

void straight() {
  //Directions:
  LEFT_MOTOR_1->run(BACKWARD);
  LEFT_MOTOR_2->run(FORWARD);
  //remember, left and right motors are set up in opposite directions
  RIGHT_MOTOR_3->run(FORWARD);
  RIGHT_MOTOR_4->run(BACKWARD);

  //Speed:
  LEFT_MOTOR_1->setSpeed(MAX_SPEED);
  LEFT_MOTOR_2->setSpeed(MAX_SPEED);
  RIGHT_MOTOR_3->setSpeed(MAX_SPEED);
  RIGHT_MOTOR_4->setSpeed(MAX_SPEED);
}

void right() {
  //Directions:
  LEFT_MOTOR_1->run(BACKWARD);
  LEFT_MOTOR_2->run(FORWARD);
  //remember, left and right motors are set up in opposite directions
  RIGHT_MOTOR_3->run(FORWARD);
  RIGHT_MOTOR_4->run(BACKWARD);

  //Speed:
  LEFT_MOTOR_1->setSpeed(255);
  LEFT_MOTOR_2->setSpeed(255);
  RIGHT_MOTOR_3->setSpeed(60);
  RIGHT_MOTOR_4->setSpeed(60);
}

void reverse() {
  //Directions:
  LEFT_MOTOR_1->run(FORWARD);
  LEFT_MOTOR_2->run(BACKWARD);
  //remember, left and right motors are set up in opposite directions
  RIGHT_MOTOR_3->run(BACKWARD);
  RIGHT_MOTOR_4->run(FORWARD);

  //Speed:
  LEFT_MOTOR_1->setSpeed(MAX_SPEED);
  LEFT_MOTOR_2->setSpeed(MAX_SPEED);
  RIGHT_MOTOR_3->setSpeed(MAX_SPEED);
  RIGHT_MOTOR_4->setSpeed(MAX_SPEED);
}
void rightSharp() {  // Check motor directions such that it turn on the spot, not curve
  //Directions:
  LEFT_MOTOR_1->run(BACKWARD);
  LEFT_MOTOR_2->run(FORWARD);
  //remember, left and right motors are set up in opposite directions
  RIGHT_MOTOR_3->run(FORWARD);
  RIGHT_MOTOR_4->run(BACKWARD);

  //Speed:
  LEFT_MOTOR_1->setSpeed(MAX_SPEED);
  LEFT_MOTOR_2->setSpeed(MAX_SPEED);
  RIGHT_MOTOR_3->setSpeed(MAX_SPEED);
  RIGHT_MOTOR_4->setSpeed(MAX_SPEED);
}

void left() {
  //Directions:
  LEFT_MOTOR_1->run(BACKWARD);
  LEFT_MOTOR_2->run(FORWARD);
  //remember, left and right motors are set up in opposite directions
  RIGHT_MOTOR_3->run(FORWARD);
  RIGHT_MOTOR_4->run(BACKWARD);

  //Speed:
  //note: right goes slow, left stays still
  LEFT_MOTOR_1->setSpeed(60);
  LEFT_MOTOR_2->setSpeed(60);
  RIGHT_MOTOR_3->setSpeed(255);
  RIGHT_MOTOR_4->setSpeed(255);
}

void leftSharp() {  // Check motor directions
  // Directions:
  LEFT_MOTOR_1->run(FORWARD);
  LEFT_MOTOR_2->run(BACKWARD);
  RIGHT_MOTOR_3->run(BACKWARD);
  RIGHT_MOTOR_4->run(FORWARD);

  // Speed:
  // Note: right goes slow, left stays still
  LEFT_MOTOR_1->setSpeed(MAX_SPEED);
  LEFT_MOTOR_2->setSpeed(MAX_SPEED);
  RIGHT_MOTOR_3->setSpeed(MAX_SPEED);
  RIGHT_MOTOR_4->setSpeed(MAX_SPEED);
}

void T_intersection() {

  leftSharp();
  // Read the sensor values again
  newSensorValue1 = digitalRead(IR_PIN_1);
  newSensorValue2 = digitalRead(IR_PIN_2);
  newSensorValue3 = digitalRead(IR_PIN_3);
  newSensorValue4 = digitalRead(IR_PIN_4);
  if (newSensorValue1 == 0 && newSensorValue2 == 0 && newSensorValue3 == 0 && newSensorValue4 == 0) {
    rightSharp();
    rightSharp();
  }
}

void intersection() {
  straight();
  delay(1000);

  // Read the sensor values again
  int newSensorValue1 = digitalRead(IR_PIN_1);
  int newSensorValue2 = digitalRead(IR_PIN_2);
  int newSensorValue3 = digitalRead(IR_PIN_3);
  int newSensorValue4 = digitalRead(IR_PIN_4);

  if (newSensorValue1 == 1 && newSensorValue2 == 1 && newSensorValue3 == 1 && newSensorValue4 == 1) {
    reverse();
    delay(1000);
    T_intersection();
  }
}

void stop() {
  LEFT_MOTOR_1->setSpeed(0);
  LEFT_MOTOR_2->setSpeed(0);
  RIGHT_MOTOR_3->setSpeed(0);
  RIGHT_MOTOR_4->setSpeed(0);
  LEFT_MOTOR_1->run(RELEASE);
  LEFT_MOTOR_2->run(RELEASE);
  RIGHT_MOTOR_3->run(RELEASE);
  RIGHT_MOTOR_4->run(RELEASE);
}
